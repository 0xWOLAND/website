<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Quantum Random Number Generator</title>
  <link rel="icon" type="image/svg+xml" href="../../favicon.svg">
  <link rel="stylesheet" href="../../css/default.css">
  <link rel="stylesheet" href="../../css/syntax.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16/dist/katex.min.js" onload="document.querySelectorAll('.math.inline').forEach(function(e){katex.render(e.textContent,e,{throwOnError:false})});document.querySelectorAll('.math.display').forEach(function(e){katex.render(e.textContent,e,{throwOnError:false,displayMode:true})})"></script>
  <script>!function () { var t = localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme:dark)').matches ? 'dark' : 'light'); document.documentElement.className = t }()</script>
</head>

<body>
  <button class="theme-toggle" onclick="var n=document.documentElement.className==='dark'?'light':'dark';document.documentElement.className=n;localStorage.setItem('theme',n)" aria-label="Toggle theme"><span class="sun">☼</span><span class="moon">☾</span></button>
  <article>
  <div class="article-header">
    <h1>Quantum Random Number Generator</h1>
    <p class="dateline">October 19, 2025 &nbsp;&middot;&nbsp; quantum</p>
  </div>
  <hr>
  <blockquote>
<p>First time trying anything quantum computing w/ my friend Shuhul from Caltech :)</p>
</blockquote>
<h1 id="prompt">Prompt</h1>
<figure>
<img src="../../images/quantum/prompt.png" alt="Prompt" />
<figcaption aria-hidden="true">Prompt</figcaption>
</figure>
<figure>
<img src="../../images/quantum/example.png" alt="Example Circuit" />
<figcaption aria-hidden="true">Example Circuit</figcaption>
</figure>
<p>In this project for QiskitFest@UCLA, we implement a Quantum random number generator that uniformly samples <span class="math inline">0...N</span> in the fewest number of qubits and gates as possible. We include 4 sample circuits ranging from a naiive implementation to the most optimal design.</p>
<h1 id="preliminaries">Preliminaries:</h1>
<p>Quickly, this problem of sampling <span class="math inline">0..N</span> is trivial for the case <span class="math inline">N = 2^k</span>, since we can use a series of Hadamard transforms to evenly split the amplitudes across all <span class="math inline">2^k</span> computational basis states. Each Hadamard gate doubles the number of possible outcomes, creating a uniform superposition where every basis state has equal probability <span class="math inline">1/2^k</span>. This only becomes interesting when <span class="math inline">N</span> isn’t just a power of <span class="math inline">2</span>, for which we explore a series of circuit constructions. Naiively, we could just simulate extra states and use rejection sampling, but we wanted to design this circuit to operate purely on a quantum state.</p>
<h1 id="v0-naiive-control">V0: Naiive Control</h1>
<figure>
<img src="../../images/quantum/v0.png" alt="Ry Rotation Gates" />
<figcaption aria-hidden="true">Ry Rotation Gates</figcaption>
</figure>
<p>In this circuit, we manually set the probabilities of each qubit using cascaded <span class="math inline">R_y</span> rotations, but this approach quickly becomes impractical. Each new qubit requires multiple controlled rotations whose angles depend on all previous qubits, causing the gate count and circuit depth to grow quadratically. These controlled rotations are also error-prone and hardware-expensive, and the precise rotation values are hard to compute or calibrate.</p>
<h1 id="v1-binary-expansion">V1: Binary Expansion</h1>
<p>Since for powers of 2, building a uniform sampler is straightforward using Hadamard gates, we instead view <span class="math inline">N</span> as a sum of powers of two, <span class="math inline">N = 2^{k_1} + 2^{k_2} + \cdots + 2^{k_m}</span>. By constructing uniform superpositions for each <span class="math inline">2^{k_i}</span> block and combining them with conditional rotations, we can approximate a uniform distribution over <span class="math inline">0...N-1</span> while keeping the circuit shallow and efficient.</p>
<h3 id="example">Example</h3>
<p>Here is an example of the breakdown for <span class="math inline">N = 7</span>:</p>
<figure>
<img src="../../images/quantum/v1_explanation.png" alt="Binary tree" />
<figcaption aria-hidden="true">Binary tree</figcaption>
</figure>
<p>And here is the corresponding circuit representation
<img src="../../images/quantum/v1.png" alt="V1 Circuit" /></p>
<p>We recursively sample over <span class="math inline">N = 7</span> states as a binary tree of conditional probabilities. At each branching point, the circuit applies a rotation that splits the amplitude proportionally to how many valid states remain in each subtree.</p>
<p>For instance, the first qubit has probability <span class="math inline">P(4/7)</span> of being <span class="math inline">|0\rangle</span> and <span class="math inline">P(3/7)</span> of being <span class="math inline">|1\rangle</span>. These are then recursively refined until all of the basis states are assigned equal amplitude.</p>
<h3 id="some-math">Some Math</h3>
<blockquote>
<p>For the first qubit, we want to split the probability mass between the left and right branches according to how many valid states lie under each.
<span class="math display">
P(0) = \frac{4}{7}, \quad P(1) = \frac{3}{7}.
</span>
An <span class="math inline">R_y(\theta)</span> gate on <span class="math inline">|0\rangle</span> prepares
<span class="math display">
R_y(\theta)|0\rangle = \cos\left(\frac{\theta}{2}\right)|0\rangle + \sin\left(\frac{\theta}{2}\right)|1\rangle,
</span>
giving probabilities <span class="math inline">\cos^2(\frac{\theta}{2})</span> and <span class="math inline">\sin^2(\frac{\theta}{2})</span>. Setting <span class="math inline">\cos^2(\frac{\theta}{2}) = \frac{4}{7}</span> yields
<span class="math display">
\boxed{\theta = 2\arccos\sqrt{\frac{4}{7}} = 2\arcsin\sqrt{\frac{3}{7}}.}
</span></p>
</blockquote>
<h1 id="v2-consolidating-hadamards">V2: Consolidating Hadamards</h1>
<figure>
<img src="../../images/quantum/v2.png" alt="V2 Image" />
<figcaption aria-hidden="true">V2 Image</figcaption>
</figure>
<p>Since the Hadamard gate is unitary, applying it twice yields the identity operation <span class="math inline">H^\dagger H = I</span>. Previously, we used a Hadamard gate with a control to emulate an anti-control, but since H is self-inverse, we can simplify the circuit by directly using an anti-control instead, reducing unnecessary gates.</p>
<h1 id="v3-complement-graph">V3: Complement Graph</h1>
<figure>
<img src="../../images/quantum/v3.png" alt="V3 Image" />
<figcaption aria-hidden="true">V3 Image</figcaption>
</figure>
<p>This approach first builds a fully balanced superposition over <span class="math inline">2^k</span> states using Hadamard gates, then applies conditional <span class="math inline">R_y</span> rotations to correct the amplitudes for <span class="math inline">N &lt; 2^k</span>. The Hadamard layer creates an even base distribution, while the correction step prunes invalid branches, creating an even more compact circuit.</p>
<h3 id="example-1">Example</h3>
<p>For <span class="math inline">N=9</span>, where the first split is <span class="math inline">N_0=8</span> and <span class="math inline">N_1=1</span>, the rotation angle is</p>
<p><span class="math display">\theta = 0.680 \text{ rad},</span></p>
<p>so relative to a Hadamard baseline (<span class="math inline">\pi/2</span>), the correction is</p>
<p><span class="math display">\Delta\theta = -0.891 \text{ rad}.</span></p>
<h1 id="v4-log-depth-hadamard-expansion">V4: Log-depth Hadamard Expansion</h1>
<figure>
<img src="../../images/quantum/v4.png" alt="V4 Image" />
<figcaption aria-hidden="true">V4 Image</figcaption>
</figure>
<p>To build a uniform quantum state over <span class="math inline">0 \ldots N-1</span>, we basically follow the binary expansion of <span class="math inline">N</span>. Each power of two, <span class="math inline">2^j</span>, is like a “block” of evenly distributed states, and you only need <span class="math inline">j</span> Hadamards to generate it, since each Hadamard doubles your reach. So if <span class="math inline">N=9=8+1</span>, you use three
Hadamards to cover the first eight states and then just patch in the last one. The key idea is that you don’t brute-force all <span class="math inline">N</span> outcomes – you
reuse the structure of powers of two to get there in about <span class="math inline">\log N</span> steps, with a few small corrections at the end to make everything line up
perfectly.</p>
<p>There might be a slightly more clever way of reducing the number of control gates, but this is the best we could do up to gates and number of qubits.</p>
<h1 id="exercise-for-fun">Exercise (for fun)</h1>
<p>Let <span class="math inline">k = \lceil \log_2 N \rceil</span> and <span class="math inline">D = 2^k - N</span>.</p>
<p>Estimate when the complement approach (cost <span class="math inline">O(D)</span>)
becomes less efficient than the Hadamard tree method (cost
<span class="math inline">O(\log N)</span>).</p>
  <div class="article-footer">
    <a href="../../">&larr; back to index</a>
  </div>
</article>

</body>

</html>
