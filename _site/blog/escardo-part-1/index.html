<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Escardó’s Exhaustive Search: Part 1</title>
  <link rel="icon" type="image/svg+xml" href="../../favicon.svg">
  <link rel="stylesheet" href="../../css/default.css">
  <link rel="stylesheet" href="../../css/syntax.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16/dist/katex.min.js" onload="document.querySelectorAll('.math.inline').forEach(function(e){katex.render(e.textContent,e,{throwOnError:false})});document.querySelectorAll('.math.display').forEach(function(e){katex.render(e.textContent,e,{throwOnError:false,displayMode:true})})"></script>
  <script>!function () { var t = localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme:dark)').matches ? 'dark' : 'light'); document.documentElement.className = t }()</script>
</head>

<body>
  <button class="theme-toggle" onclick="var n=document.documentElement.className==='dark'?'light':'dark';document.documentElement.className=n;localStorage.setItem('theme',n)" aria-label="Toggle theme"><span class="sun">☼</span><span class="moon">☾</span></button>
  <article>
  <div class="article-header">
    <h1>Escardó’s Exhaustive Search: Part 1</h1>
    <p class="dateline">July 25, 2025 &nbsp;&middot;&nbsp; math, pltheory</p>
  </div>
  <hr>
  <h1 id="introduction">Introduction</h1>
<p>I’ve recently read <a href="https://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/">this</a> old blog post by Andrej Bauer about Martin Escardó’s <a href="https://martinescardo.github.io/papers/exhaustive.pdf"><em>Infinite sets that admit fast exhaustive search</em></a>. At first, it seems pretty ridiculous! How is it possible to decide a problem that is embedded in an infinite topological space? However, using some nice tricks from functional programming and higher-level computability, we can achieve this and even explore some other unexpected consequences.</p>
<p>Any finite set is immediately exhaustible<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, but the interesting thing is that certain infinite sequences with specific properties can also be exhaustible.</p>
<h2 id="notation">Notation</h2>
<p>The simple types are <span class="math inline">\sigma, \tau := o | \iota | \sigma \times \tau | \rightarrow \tau</span>. Let’s dig into this a bit more.
- <span class="math inline">o</span> the Booleans which in Haskell are <code>Bool = True | False</code>
- <span class="math inline">\iota</span> (natural numbers), written as <code>Int</code>.
- Product type <span class="math inline">\sigma \times \tau</span> is the Cartesian product, which is <code>IntMap a</code> <span class="math inline">: \tau \times</span> <code>(Maybe a)</code>
- Function type <span class="math inline">\sigma \rightarrow \tau</span>
- <span class="math inline">\iota \rightarrow o</span> = predicates on the naturals
- <span class="math inline">o \rightarrow o</span> = boolean functions <span class="math inline">\neg, \land, \lor</span>, etc.</p>
<p>Using these primitives, we can construct increasingly more complex types as:</p>
<p>Base case (level 0):
- <span class="math inline">o</span> = booleans
- <span class="math inline">\iota</span> = natural numbers</p>
<p>Level 1:
- <span class="math inline">o \times o</span> = pair of booleans <code>(True, False)</code>
- <span class="math inline">\iota \times \iota</span> = pair of naturals <code>(3, 7)</code>
- <span class="math inline">o \rightarrow o</span> = boolean functions <code>{NOT, AND True, OR False, id, ...}</code>
- <span class="math inline">\iota \rightarrow o</span> = predicates on naturals <code>{isEven, isPrime, λn.n&gt;5}</code>
- <span class="math inline">\iota \rightarrow \iota</span> = arithmetic functions, <code>{successor, λn.2*n, λn.n²}</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Oracle</span> a <span class="ot">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a        <span class="co">-- ι → a (where a could be o, ι, etc.)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pred</span> a <span class="ot">=</span> <span class="dt">Oracle</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>  <span class="co">-- (ι → a) → o  </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Prefix</span> <span class="ot">=</span> <span class="dt">IntMap</span> <span class="dt">Bool</span>        <span class="co">-- finite partial assignments  </span></span></code></pre></div>
<ul>
<li>The domain is a Cantor space <span class="math inline">\mathbb{B}^\mathbb{N}</span> (all boolean streams)</li>
<li>A predicate <code>p</code> is a higher-type functional <span class="math inline">p: (\mathbb{B}^\mathbb{N}) \rightarrow \mathbb{B}</span></li>
<li>a prefix <code>asg</code> is a finite partial map <span class="math inline">\alpha : S \rightarrow \mathbb{B}</span> which is used to define the <a href="https://en.wikipedia.org/wiki/Cylinder_set">cylinder sets</a> used to define the product topology on the Cantor space.
### Scott Domains
For each type <span class="math inline">\sigma</span>, there is a <strong>Scott domain</strong> <span class="math inline">D_\sigma</span> of partial functionals of the that same type <span class="math inline">\sigma</span> defined by lifting the type <span class="math inline">\sigma</span> to contain the <code>undefined</code> type with all of the properties you would expect (e.g. ordering, etc.). In Haskell, this looks like an <code>Oracle a</code> type with potential <code>Need</code> exceptions. This lets us capture the behavior of undefined/non-terminating computation, which we use to create <em>partial</em> oracles.</li>
</ul>
<h3 id="total-functionals-t_sigma-subseteq-d_sigma">Total functionals <span class="math inline">T_\sigma \subseteq D_\sigma</span></h3>
<p>A functional is <strong>total</strong> if it maps total inputs to total outputs (so it never produces a <code>Nothing</code> type from non-<code>Nothing</code>)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalP ::</span> <span class="dt">Pred</span> a <span class="ot">-&gt;</span> <span class="dt">Prefix</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Bool</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>evalP p asg <span class="ot">=</span> <span class="kw">case</span> unsafePerformIO (try (evaluate (p (oracle <span class="fu">undefined</span> asg)))) <span class="kw">of</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> (<span class="dt">Need</span> i) <span class="ot">-&gt;</span> <span class="dt">Left</span> i    <span class="co">-- Partial: needs position i</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> b <span class="ot">-&gt;</span> <span class="dt">Right</span> b         <span class="co">-- Total on this prefix</span></span></code></pre></div>
<p>So then we can evaluate <span class="math inline">P(f^\perp)</span> where <span class="math inline">f^\perp</span> is a partial oracle depending on what the domain is.</p>
<h1 id="constructive-selection-functional-for-cantor-space">Constructive Selection Functional for Cantor Space</h1>
<p>Now consider the following code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">escardo ::</span> <span class="dt">Pred</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Oracle</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>escardo p <span class="ot">=</span> <span class="fu">fmap</span> extend (go IM.empty) <span class="kw">where</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  extend asg i <span class="ot">=</span> IM.findWithDefault <span class="dt">False</span> i asg</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  go asg <span class="ot">=</span> <span class="kw">case</span> evalP p asg <span class="kw">of</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">Just</span> asg</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> i <span class="ot">-&gt;</span> <span class="kw">case</span> go (IM.insert i <span class="dt">False</span> asg) <span class="kw">of</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> a</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> go (IM.insert i <span class="dt">True</span> asg)</span></code></pre></div>
<p>We maintain a finite assignment <code>asg</code> that fixes the values of a few coordinates so far. <code>evalP</code> determines whether this cylinder already forces the truth value of <code>p</code>. If <code>evalP p asg</code> returns <code>Right True</code>, then <span class="math inline">p</span> is already true for every infinite bitstream extending <code>asg</code>. Then we can just stop and produce a total oracle by calling <code>extend</code>, which fills every unspecified bit (at this current point) with a default value (<code>False</code>).</p>
<p><strong><em>But what does this mean?</em></strong> Think of the Cantor space as the set of all infinite binary sequences</p>
<p><span class="math display">
    000000000... \\
    001010110... \\
    010101010... \\
    111111111... \\
</span></p>
<p>From Wikipedia,
&gt; Given a collection <span class="math inline">S</span> of sets, consider the Cartesian product <span class="math inline">X = \Pi_{Y \in S} Y</span> of all sets in the collection. The <strong>canonical projection</strong> corresponding to some <span class="math inline">Y \in S</span> is the function <span class="math inline">p_Y : X \rightarrow Y</span> that maps every element of the product to its <span class="math inline">Y</span> component. <strong>A cylinder set is a preimage of a canonical projection</strong> or finite intersection of such preimages. Explicitly, we can write it as:
<span class="math display">
\bigcap_{i = 1}^n p_{Y_i}^{-1} (A_i) = \{(x) \in X | p_{Y_1} \in A_1, \cdots, p_{Y_n} (x) \in A_n \}
</span></p>
<p>So for the Cantor space, a cylinder <span class="math inline">[\alpha]</span> consists of the set of all infinite strings that start with a finite prefix <span class="math inline">\alpha</span>. For example,
- <code>[01]</code> = all strings that start with “01”:
<span class="math display">
01000000... \\
01001010... \\
01010101... \\
01111111... \\
</span>
- <code>[101]</code> = all strings starting with “101”:
<span class="math display">
10100000... \\
10101010... \\
10111111... \\
</span></p>
<p>We can illustrate this as a tree:</p>
<div style="background-color: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
  <div style="display: flex; justify-content: center;">
    <img src="../../images/escardo/cylinder_set.png" alt="Cylinder Set" style="width: 50%; height: auto;" />
  </div>
</div>
<p><em>The cylinder set corresponds to the subtree circled in red in the case of the Cantor space.</em></p>
<p>So then, the search process starts at the root and recursively tries to decide <span class="math inline">p</span> on the current space (starting with the entire Cantor space). If we need bit <span class="math inline">i</span>, then split the current cylinder into two subcylinders. If a cylinder returns <code>Right False</code>, we abandon the subtree and if a cylinder returns <code>Right True</code>, we short-circuit and accept.</p>
<p>The incredible thing is that predicate <span class="math inline">p</span> in this case can be incredibly general. The simplest form to imagine are SAT-style boolean combinations, but they can be <strong>any continuous function decidable with finite information</strong>. For instance, all of the following are compatible with this framework and are decidable efficiently:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Arithmetic predicate</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">sumFirst10 ::</span> <span class="dt">Pred</span> <span class="dt">Int</span>  </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>sumFirst10 oracle <span class="ot">=</span> <span class="fu">sum</span> [oracle i <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">9</span>]] <span class="op">&gt;</span> <span class="dv">50</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pattern matching</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="ot">hasPattern ::</span> <span class="dt">Pred</span> <span class="dt">Bool</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>hasPattern oracle <span class="ot">=</span> <span class="fu">any</span> (\i <span class="ot">-&gt;</span> oracle i <span class="op">&amp;&amp;</span> oracle (i<span class="op">+</span><span class="dv">1</span>) <span class="op">&amp;&amp;</span> <span class="fu">not</span> (oracle (i<span class="op">+</span><span class="dv">2</span>))) [<span class="dv">0</span><span class="op">..</span><span class="dv">97</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Convergence predicate  </span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="ot">converges ::</span> <span class="dt">Pred</span> <span class="dt">Double</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>converges oracle <span class="ot">=</span> <span class="fu">abs</span> (oracle <span class="dv">100</span> <span class="op">-</span> oracle <span class="dv">99</span>) <span class="op">&lt;</span> <span class="fl">0.001</span></span></code></pre></div>
<p>and these aren’t easily expressible using an SAT-style alphabet. The key constraint is <em>continuity</em>, not logical structure.</p>
<h1 id="for-the-sake-of-mathematical-rigor">for the sake of mathematical rigor</h1>
<p>Recall that formally, the predicate is defined as <span class="math inline">p: \mathbb{B}^\mathbb{N} \rightarrow \mathbb{B}</span> a continuous map on the Cantor space, which itself is a countable product space. The basic open sets in this space are the aforementioned cylinders <span class="math inline">[\alpha]</span>, which are infinite bitstreams that extend a finite assignment <span class="math inline">\alpha : S \rightarrow \mathbb{B}</span>. By the (Kleene-Kreisel) continuity of <span class="math inline">p</span>, there exists some cylinder <span class="math inline">[\alpha] \ni x</span> for each <span class="math inline">x</span> on which <span class="math inline">p</span> is already constant and hence a finite amount of information about the input fixes the output. Because the Cantor space is compact and totally disconnected, the preimages <span class="math inline">p^{-1} (1)</span> and <span class="math inline">p^{-1} (0)</span> are <em>clopen</em>, so each can be written as a finite union of cylinders (this is a pretty standard trick). Refining these finitely many cylinders to a common depth yields a uniform modulus<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> (via Heine-Cantor) <span class="math inline">N</span> such that for each <span class="math inline">x</span>, <span class="math inline">p(x)</span> is determined by some finite set of at most <span class="math inline">N</span> bits.</p>
<p>The <code>evalP</code> function implements this. Given a finite assignment <span class="math inline">alpha</span> (the <code>IntMap</code>), we run <span class="math inline">p</span> against the partial oracle that answers exactly the bits in <span class="math inline">\alpha</span> and throws <code>Need</code> when an unassigned bit is requested. This is exactly the “dialogue” that Escardó describes in his paper: <strong>continuous higher-type functionals consuming only finite information.</strong>.</p>
<p>So really, this is just an incredibly complex guided depth-first search over the binary decision tree of finite assignments that branches only when <span class="math inline">p</span> asks for a new bit with some short-circuiting logic. Termination relies on compactness via the uniform modulus <span class="math inline">N</span>. <code>Left i</code> can appear only when <code>i</code> is new (once a bit is assigned, accessing it later doesn’t throw a <code>Need</code>). Thus, no successful branch can be longer than <span class="math inline">N</span>, so after at most <span class="math inline">N</span> distinct queries continuity forces a <code>Right</code> answer. If <code>p</code> is everywhere false, the algorithm will explore all finitely many branches up to depth <span class="math inline">N</span> and fail and otherwise terminate early. Thus, we constructively determine that the Cantor space is searchable<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Another nice property of this is that the order that we sample branches doesn’t affect correctness, only runtime (so there are many engineering optimizations to be done…maybe Gray codes?).</p>
<blockquote>
<p>The TL;DR is that:
- Continuity gives you cylinder-faithfulness
- Compactness gives you a uniform finite modulus
- Dialogue gives you an on-demand DFS that decides the predicate over finite information</p>
</blockquote>
<h1 id="why-just-the-cantor-space">why just the cantor space?</h1>
<div style="background-color: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
  <div style="display: flex; justify-content: center;">
    <img src="../../images/escardo/padic.png" alt="p-adic number" style="width: 50%; height: auto;" />
  </div>
</div>
<p><em>Good ol’ Wikipedia image. Unfortunately took me a few months to fully wrap my head around them.</em></p>
<p>The <span class="math inline">p</span>-adic integers<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> <span class="math inline">\mathbb{Z}_p</span> can similarly be seen as an infinite stream of digits in the base <span class="math inline">p</span> much like the Cantor space (as shown above).</p>
<p><span class="math display">
    x = a_0 + a_1p + a_2 p^2 + \cdots, a_i \in \{ 0, 1, \cdots, p - 1 \}
</span></p>
<p>Really, the only difference is that now the alphabet size is now <span class="math inline">p</span> instead of restricted to <span class="math inline">2</span>. The Cantor space is kind of an artificial playground because conceptually it is pretty simple to understand. However, the <span class="math inline">p</span>-adics are widely applicable across number theory (<a href="https://en.wikipedia.org/wiki/Hensel%27s_lemma">Hensel’s lemma always surprises me</a>) and more. We can easily compute the answer for the question “does there exist a <span class="math inline">p</span>-adic number <span class="math inline">\geq k</span> that satisfies <span class="math inline">C</span> condition?” and construct a witness for it. At some point, i’ll implement a root finding constructive algorithm…maybe pure Haskell WolframAlpha??</p>
<p>There is also an extension of this that introduces <a href="https://softwareengineering.stackexchange.com/questions/202908/how-do-functional-languages-handle-random-numbers/202915#202915">Randomness</a> and in turn has some interesting measure-theoretic and algorithmic properties..</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>A set <span class="math inline">K</span> is <em>exhaustible</em> if for any decidable predicate <span class="math inline">p</span>, there is a deterministic algorithm to determine whether all elements of <span class="math inline">K</span> satisfy <span class="math inline">p</span>. Formally, we can write that for a functional type <span class="math inline">(C \rightarrow \mathbb{B}) \rightarrow \mathbb{B}</span> with <span class="math inline">K \subseteq C</span>. The input is a predicate <span class="math inline">p: C \rightarrow \mathbb{B}</span> and the output is <span class="math inline">p(x)</span> holds for all <span class="math inline">x \in K</span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>From Wikipedia: a modulus of continuity is a function <span class="math inline">\omega: [0, \infty] \rightarrow [0, \infty]</span> used to measure the uniform continuity of functions. So we can write <span class="math inline">|f(x) - f(y)| \leq \omega(|x - y|)</span><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>A set <span class="math inline">K</span> is <em>searchable</em> if there is a computable functional <span class="math inline">\epsilon_K : (D \rightarrow B) \rightarrow D</span> such that for every <span class="math inline">p</span> defined on <span class="math inline">K</span>, <span class="math inline">\epsilon_k (p) \in K</span> and $p(x) = $ <code>True</code> for some <span class="math inline">x \in K</span> implies that $p(_K (p)) = $ <code>True</code>. Thus, searchability <span class="math inline">\implies</span> exhaustibility<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Distance is measured as <span class="math inline">|x|</span> over the normal number line but in the <span class="math inline">p</span>-adic form, <span class="math inline">|x|_p = p^{-k}</span> and <span class="math inline">x = p^k \cdot \frac{a}{b}</span>. <span class="math inline">p</span>-adics also have cylinder sets (which are now residue classes <span class="math inline">\mod p^k</span>) and form the sasme tree-like structure where depth 1 represents mod 3 classes, depth 2 is mod 9 classes, etc. for <span class="math inline">p = 3</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  <div class="article-footer">
    <a href="../../">&larr; back to index</a>
  </div>
</article>

</body>

</html>
